

### 1. 배열의 특징
1. 배열과 인덱스 -  **O(1)** 
	- 배열에서 자료를 찾을때 인덱스를 사용하면 매우 빠르게 자료를 찾을수 있다.
	- 인덱스를 통한 입력, 변경, 조회의 경우 **한번의 계산으로 자료의 위치를 찾을 수 있다.**
		- 메모리 구조
			- ![[Pasted image 20250404213223.png]]
		- 배열에서는 arr[2]의 위치를 바로 찾을수 있는데 기본적으로 베열은 주소 값을 참조하고 있다 각 배열은 메모리상에 순서대로 붙어서 존재하고 int는 4byte를 차지한다. 따라서 배열의 위치 부터 시작해서 자료의 크기와 인덱스 번호를 곱하면 원하는 메모리 위치를 찾을수 있다.
			- 계산 공식 : 배열의 시작 참조 + (자료의 크기 * 인덱스의 위치) 
2. 배열의 검색 - **O(n)** 
	- 배열에 들어있는 데이터를 찾는것을 검색이라고 하는데 배열에 있는 모든 데이터를 하나하나 비교해야한다. 이때 이전과 같이 인덱스를 사용해서 한번에 찾을수는 없고 배열안에 들어 있는 데이터를 하나하나 확인해야한다.
	- 배열의 크기가 n이면 연산도 n만큼 필요하다.
3. 빅오(O) 표기법
	- 알고리즘의 성능을 분석할 때 사용하는 수학적 표현 방식.
	- 알고리즘의 정확한 실행 시간을 계산하는것이 아니라, 데이터 양의 증가에 따른 성능의 변화 추세를 이해해는 것.
	- 빅오(O) 표기법
		1. O(1) 
			- 상수 시간 : 입력 데이터의 크기에 관계없이 알고리즘의 실행 시간이 일정
		2. O(n)
			- 선형 시간 : 알고리즘의 실행 시간이 입력 데이터의 크기에 비례하여 증가한다.
		3. O(n2)
			- 제곱 시간 : 알고리즘의 실행시간이 입력 데이터의 크기에 제곱하여 증가한다. 
		4. O(log n)
			- 로그 시간 : 알고리즘의 실행 시간이 데이터 크기의 로그에 비례하여 증가한다.
		5. O(n log n)
			- 선형 로그 시간
	- 빅오 표기법은 보통 최악의 상황을 가정해서 표기함.
4. 배열의 데이터 추가
	- 추가는 기존 데이터를 유지하면서 새로운 데이터를 입력하는것, 데터를 중간에 추가하면 기존 데이터가 오르쪽으로 한칸씩 추가
		- 배열에 데이터를 추가하는 위치에 따라 3가지로 나눔
			1. 배열의 첫번째 위치에 추가
				- 배열의 첫번째 위치를 찾는데는 O(1) 이걸림
				- 모든 데이터를 배열의 크기만큼 한 칸씩 이동 O(n)
				- O(1 + n) -> O(n)이 된다.
			2. 배열의 중간 위치에 추가
				- 배열의 위치를 찾는데 O(1)이 걸림
				- index의 오른쪽에 있는 데이터를 모두 한칸씩 이동 -> O(n / 2)
				- O( 1 + n  / 2) -> O(n)
			3. 배열의 마지막 위치에 추가
				- 기존배열을 이동하지 않으므로 O(1) 이 된다.
			- 배열에 값을 추가할때 위치가 상관이 없으면 마지막 위치에 추가하는데 더 빠르다는걸 알 수 있다.
5. 배열의 한계
	- 배열은 가장 기본적인 자료구조이고 인덱스를 사용할때 최고의 효율이 나온다.
	- 하지만 배열의 크기를 배열을 생성하는 시점에 미리 정해야 한다는 단점이 있다.
	- 배열처럼 처음부터 정적으로 길이가 정해져 있는것이 아니라 동적으로 길이를 늘리고 줄일수 있는 자료구조가 있으면 편리할것이다. 이런 동적으로 길이를 조절할수 있는것이 List 이다.

<br>
### 2. 배열의 리스트
1. List 자료 구조
	- 순서가 있고, 중복을 허용하는 자료구조를 List라고 한다. 배열과 비슷하지만 배열은 정적이고, List는 동적이라는 특징이 있다.
	- 실제로는 List도 배열이지만, 배열에 메모리 공간이 가득차는 순간 배열의 공간을 늘리는 기능이 탑제 되어 있어 동적으로 배열을 늘리게 되어 있다.
2. 데이터의 삭제
	- 삭제 또한 배열의 데이터 삭제와 같이 삭제하는 값 포함해서 왼쪽으로 1칸씩 이동한다.
	- 삭제하는 데이터를 찾는것은 O(1), 왼쪽으로 이동하는 것은 O( 1 - n / 2) ->  O(n) 이된다.
3. 정리
	- 배열 리스트는 마지막에 데이터를 추가하거나 마지막에 있는 데이터를 삭제할 때는 O(1)로 매우 빠르지만, 중간에 데이터를 추가하거나 삭제하는 경우에는 O(n)으로 느리다.
	- 보통 데이터를 중간에 추가하고 삭제하는 변경보다는, 데이터를 순서대로 입력하고, 순서대로 출력하는 경우에 가장 호율적이다.

### 3. 배열과 제네릭
- 기본적으로 배열은 Object를 사용하여 모든 타입을 수용한다. 하지만 모든 타입을 수용하면 타입 안정성이 떨어질수 있기 때문에 [[제네릭 컬렉션]]을 사용하여 타입 안정성을 지키면서 모든 타입을 수용할수 있다.

### 4. 정리
- 배열 리스트는 순서대로 마지막에 데이터를 추가하거나 삭제할 때는 성능이 좋지만, 앞이나 중간에 데이터를 추가하거나 삭제할 때는 성능이 좋지 않다. 이러한 단점을 해결한 자료구조가 링크드 리스트([[LinkedList]])라고 할수 있다.