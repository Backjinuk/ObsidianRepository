

1. **제네릭이 필요한 이유**
   - 만약 정해지지 않은 타입의 데이터를 담을 클래스를 만든다고 했을 때, 이 클래스의 타입은 무엇일까?
   - 클래스의 타입을 `Object`로 만들면 어느 정도 해결되지만, 이 경우 개발자가 `Object`로 반환된 값을 다운 캐스팅해서 반환 타입을 정해야 한다.  
     사람은 항상 실수를 할 수 있기 때문에 이런 방식은 좋지 않다.
   - 결과적으로 이 방식은 타입 안정성이 떨어지는 방식이라고 볼 수 있다.

2. **제네릭**
   - 제네릭을 사용하면 코드 재사용성과 타입 안정성을 모두 만족할 수 있다.
   - `<T>`를 사용한 클래스를 제네릭 클래스라고 한다.
   - 제네릭 클래스를 사용할 때는 타입을 미리 정하지 않고, 타입 매개변수를 활용하여 생성 시점에 `<T>`의 타입을 결정한다.
   - 이렇게 되면 컴파일 시 타입 안정성을 보장하기 때문에 안전하게 코드를 만들 수 있다.

3. **제네릭 용어와 관례**
   - 제네릭의 핵심은 사용할 타입을 미리 결정하지 않는다는 점이다.
   - 클래스 내부에서 사용하는 타입을 클래스를 정의하는 시점에 결정하는 것이 아니라, 실제 사용하는 생성 시점에 타입을 결정한다.  
     (이로 인해 재사용성이 크게 늘어난다.)
   - 제네릭에서는 **타입 매개변수** `<T>`에 **타입 인자**를 전달해서 제네릭의 사용 타입을 결정한다.
     - 예시:
       - `String`  -> `GenericBox<String>`
       - `Integer` -> `GenericBox<Integer>`
   - **용어 정리**
     - **제네릭 타입**  
       - 클래스나 인터페이스를 정의할 때 타입 매개변수를 사용하는 것을 말한다.  
       - 제네릭 클래스, 제네릭 인터페이스를 모두 합쳐서 제네릭 타입이라 한다.  (타입은 클래스, 인터페이스, 기본형을 모두 포함하는 개념이다.)
     - **타입 매개변수**  
       - 제네릭 타입이나 메서드에서 사용되는 변수로, 실제 타입으로 대체된다.
     - **타입 인자**  
       - 제네릭 타입을 사용할 때 제공되는 실제 타입.
   - **기타**
     - 제네릭은 한 번에 여러 타입 매개변수를 선언할 수 있다.
       - 예: `public class GenericBox<K, V>`
     - 제네릭은 타입 매개변수에 기본형을 사용할 수 없다.

4. **타입 매개 변수 제한**
   - 제네릭은 타입 매개변수에 어떠한 타입도 들어올수 있기 때문에 기본적으로 코드 작성시 Object로 인식이 된다. 그래서 제네릭 클래스에는 Object의 기능만 사용할수 있기 때문에 이를 방지하기 위해 타입 매개변수를 특정 타입으로 제한할수 있는 것이 타입 매개변수 제한이다.
	   - `GenericBox<T extend T>` 이렇게 사용한다.
   - 이렇게 되면 특정 타입의 기능도 사용할수 있고 최소한의 타입을 제한할수 있다.
   - 제네릭에 타입 매개변수 제한함으로써 타입 안전성을 지키면서 상위 타입의 원하는 기능까지 사용할수 있고 코드의 재사용도 늘어난다.
<br>
5. **제네릭 메서드**
	-  제네릭 타입과 제네릭 메서드는 엄연히 다른 기능을 제공하는데
		- 예시:
			- 일반 메서드 :    `public static Obejct objMethod(Object obj)`
			- 제네릭 메서드 : `public static <T> T genericMethod(T obj)`
		- 위와 같이 만들수 있는데 제네릭 클레스와는 제네릭 타입이 적용되는 범위가 다른것이 특징이다. 제네릭 클래스는 클래스 범위 전체에 해당하고 메서드는 메서드에 한에서만 제네릭이 적용이 된다.
		- 제네릭 메서드 또한 타입 매개변수 제한을 사용 가능하다.
	- 제네릭 타입은 객체를 생성하는 시점에 타입 인자가 결정이 되지만 제네릭 메서드는 메서드를 호출하는 시점에 타입 인자가 결정된다.
	- 제네릭 타입은 static 메서드에 타입 매개 변수를 사용할수 없다. 
		- 제네릭 타입은 객체를 생성하는 시점에 타입이 정해지는데 static 메서드는 인스턴스 단위가 아니라 클래스 단위로 작동하기 때문에 제네릭 타입과는 무관하기 때문
		- 따라서 static 메서드에 제네릭을 도입 할려면 제네릭 메서드를 사용해야한다.
	- 제네릭 메서드 타입 추론
		- 자바 컴파일러는 제네릭 메서드에 어떤 타입이 들어오는지 알 수 있다. 또한 반환 타입을 알 수 있는데 이런 정보를 통해 자바 컴파일러는 타입 인자를 추론할 수 있다.
			- 타입 추론 덕분에 불필요한 코드가 줄어드는데 명시적으로 타입 인자가 전달되는 것은 알고 있어야 한다.
	- 제네릭 타입과 제네릭 메서드의 우선순위
		- 제네릭 타입보다 제네릭 메서드가 높은 우선순위를 가진다.
<br>
6. **와일드 카드**
	- 하나 이상의 문자
	- 와일드 카드와 제네릭 타입과는 비슷함.
		- 이미 만들어진 제네릭 타입을 활용할때 사용하는것.
	- 제네릭 타입을 보다 쉽게 한것??
	- 와일드 카드에서도 타입 매개 변수 제한을 사용할수 있다..
		- 다만 메서드의 타입들을 특정 시점에 변경하려면 제네릭 타입이나, 제네릭 메서드를 사용해야 한다.
	- 와일드 카드에서는 상한도 지정할수 있지만 하한도 지정 가능하다.

<br>
7. *타입 이레이저*
	- 컴파일시에는 타입 매개변수와 타입 인자를 포함한 제네릭 정보를 활용한다. 
	- 하지만 컴파일이 종료 된후에는 자바는 제네릭과 관련된 정보를 삭제한다.
		- 제네릭 관련 타입을 `Object`로 변환
	- 자바 컴파일러는 제네릭을 사용하는 부분에 형변환 캐스팅 하는 코드를 추가해준다.
		- 이렇게 캐스팅 하는 코드는 자바 컴파일러가 검사를 하기 때문에 오류가 발생하지 않는다.
	- 자바의 제네릭 타입은 컴파일 시점에만 존재하고, 런타임 시에는 제네릭 정보가 지워지는데 이것을 타입 이레이저라고 한다.



[[컬렉션 프레임 워크]] 에서도 제네릭을 많이 사용한다.
<br>






